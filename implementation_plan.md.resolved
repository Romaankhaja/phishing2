# Optimization Implementation Plan

## Goal
Significantly increase the throughput of the phishing detection pipeline by optimizing resource allocation and decoupling "fast" (IO-bound) tasks from "slow" (GPU/CPU-bound) tasks.

## Problem Analysis
The current architecture processes each domain linearly:
1.  Start Domain A
2.  Fetch DNS/SSL (Fast)
3.  **Wait** for Screenshot & OCR (Slow/Heavy)
4.  Finish Domain A

The global `semaphore = 5` restricts the entire pipeline to 5 concurrent domains. This means fast network tasks are blocked by slow visual tasks. If OCR takes 2 seconds and DNS takes 0.1 seconds, your GPU is busy, but your network bandwidth is idle.

## Proposed Changes

### 1. Decoupled Pipeline Architecture (Producer-Consumer)
Instead of processing a URL start-to-finish in one go, we will split the pipeline into two parallel stages:

*   **Stage 1: High-Concurrency Network & Text Analysis**
    *   **Tasks:** DNS, Whois, SSL, URL structure, HTML text.
    *   **Concurrency:** High (e.g., 50-100 threads/tasks).
    *   **Resource:** Network Bandwidth & CPU (Light).
    *   **Action:** Run this for *all* domains immediately.

*   **Stage 2: Resource-Constrained Visual Analysis**
    *   **Tasks:** Screenshot (Playwright), OCR (EasyOCR/GPU), Branding.
    *   **Concurrency:** Low (Limited by GPU VRAM and Browser overhead, e.g., 2-4).
    *   **Resource:** GPU & RAM (Heavy).
    *   **Action:** Feed domains into a queue that is consumed by a fixed number of GPU workers.

### 2. Optimized Resource Allocation (Dynamic Throttling)
*   **Dynamic Semaphore:** instead of fixed constraints (e.g. `semaphore=5`), we will implement a `ResourceMonitor` check.
*   **Logic:**
    *   Before spawning a new "Visual" task, check:
        *   RAM Usage < 85%
        *   CPU Usage < 90%
        *   (If GPU available) VRAM Usage < 90%
    *   If resources are high, `await asyncio.sleep(1)` until they drop.
*   **Auto-Scaling Workers:** The number of concurrent workers will initially attempt to scale up to a sensible maximum (e.g., CPU core count * 2 for network, but maybe 2-4 for GPU) but will be held back by the resource monitor.

## Implementation Steps

### Phase 1: Create `resource_manager.py`
#### [NEW] `resource_manager.py`
*   Class `ResourceMonitor`:
    *   `check_availability()`: Returns True if safe to launch.
    *   Wrapper `wait_for_resources()` that blocks until safe.
    *   Uses `psutil` for CPU/RAM.
    *   Uses `torch.cuda` or `pynvml` (if available) for GPU.

### Phase 2: Refactor [pipeline.py](file:///c:/Users/SATWIK/Documents/Phishing/phishing_pipeline/pipeline.py)
#### [MODIFY] [pipeline.py](file:///c:/Users/SATWIK/Documents/Phishing/phishing_pipeline/pipeline.py)
*   Import `ResourceMonitor`.
*   Replace the single [worker](file:///c:/Users/SATWIK/Documents/Phishing/phishing_pipeline/pipeline.py#169-185) function with the Producer-Consumer model.
    *   **Producer:** Fetches rows, extracts Network features (Fast).
    *   **Consumer:** Takes Network results, calls `await monitor.wait_for_resources()`, runs Visual features (Slow), saves result.

### Phase 3: Refactor [utils.py](file:///c:/Users/SATWIK/Documents/Phishing/phishing_pipeline/utils.py) and [features.py](file:///c:/Users/SATWIK/Documents/Phishing/phishing_pipeline/features.py)
#### [MODIFY] [utils.py](file:///c:/Users/SATWIK/Documents/Phishing/phishing_pipeline/utils.py)
*   Expose fine-grained execution functions instead of just [extract_all_features_async](file:///c:/Users/SATWIK/Documents/Phishing/phishing_pipeline/utils.py#158-177).
*   (Optional) Tune Semaphores: `MAX_CONCURRENT_OCR` vs `MAX_CONCURRENT_SCREENSHOTS`.

### Phase 4: Advanced Fine-Tuning (Alternative Approaches)
These are additional strategies to further minimize execution time:

1.  **Request Interception (Block Ads/Trackers):**
    *   **Why:** Phishing sites often load heavy external trackers or ads.
    *   **How:** Use Playwright's `page.route("**/*", ...)` to block requests to known ad domains or resource types (media/fonts) that aren't critical for the visual snapshot. This can cut page load time by 30-50%.

2.  **Optimized Image Pre-processing for OCR:**
    *   **Why:** Sending a 4K or full-height screenshot to OCR is slow and memory-intensive.
    *   **How:** Resize (downscale) images to a fixed width (e.g., 1000px) and convert to Grayscale *before* passing to EasyOCR. This reduces the tensor size on the GPU significantly.

3.  **Aggressive DNS & Timeout Tuning:**
    *   **Why:** Default timeouts (30s) stick too long on dead domains.
    *   **How:**
        *   Set strict timeouts (e.g., 3-5s) for "Fast Fail".
        *   Use `aiodns` with a persistent resolver cache to avoid repeated lookups for the same nameservers.

### Phase 3: Hardware Verification
*   Add a startup check to confirm OCR is actually using `cuda` (GPU) and not [cpu](file:///c:/Users/SATWIK/Documents/Phishing/phishing_pipeline/utils.py#212-215).

## Expected Outcome
*   **Network Features:** Will complete for 1000 domains in ~1-2 minutes (vs 30+ mins previously).
*   **Visual Features:** Will run at max GPU speed.
*   **Total Time:** Reduced significantly because network latency is overlapped entirely with GPU processing.

## Verification
1.  **Benchmark:** Run a subset of 50 domains.
2.  **Monitor:** Check GPU usage (should be consistent, near 100% when active) and Network usage (should be higher).
