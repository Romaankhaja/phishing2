# Browser Lifecycle Fix Plan

## Problem
The error `BrowserContext.new_page: Target page, context or browser has been closed` occurs because:
1. A single shared browser context (`_async_context`) is used for all concurrent tasks.
2. If one task encounters a critical error or the browser crashes, the context is invalidated.
3. Subsequent tasks try to use the now-closed context, leading to the error.

## Proposed Solution: Robust Lifecycle Manager

We will refactor [visual_features.py](file:///c:/Users/SATWIK/Documents/Phishing/phishing_pipeline/visual_features.py) to replace the simple global variables with a robust `BrowserLifecycleManager` class.

### Key Changes

1.  **Context Pooling (Optional but recommended)**: Instead of one global context, use a small pool or recreate contexts on demand if they fail. For now, we'll stick to a **resilient singleton** pattern: if the context is closed, automatically create a new one.
2.  **Automatic Recovery**: Wrap `new_page()` calls in a retry loop. If `new_page()` fails because the browser is closed, restart the browser and try again.
3.  **Explicit Health Checks**: Before using a context, check if `context.is_closed()`.

## Implementation Steps

### 1. Modify [visual_features.py](file:///c:/Users/SATWIK/Documents/Phishing/phishing_pipeline/visual_features.py)

#### A. Create `BrowserManager` Class
Encapsulate the complexity of `playwright.start()`, `browser.launch()`, and `context.new_page()`.

```python
class AsyncBrowserManager:
    def __init__(self):
        self._play = None
        self._browser = None
        self._context = None
        self._lock = asyncio.Lock()

    async def get_context(self):
        async with self._lock:
            if self._context and not self._context.is_closed(): # Check if alive
                return self._context
            
            # If dead or not started, (re)start
            await self._restart_browser()
            return self._context

    async def _restart_browser(self):
        # ... cleanup old resources ...
        # ... start new playwright/browser/context ...
```

#### B. Update [capture_screenshot_async](file:///c:/Users/SATWIK/Documents/Phishing/phishing_pipeline/visual_features.py#232-274)
Use the manager to get a fresh page.

```python
async def capture_screenshot_async(...):
    manager = get_async_browser_manager() # Singleton accessor
    
    for attempt in range(max_retries):
        try:
            context = await manager.get_context()
            page = await context.new_page()
            # ... do work ...
            return
        except TargetClosedError:
             # Retry logic
```

### 2. Modify [main_controller.py](file:///c:/Users/SATWIK/Documents/Phishing/main_controller.py)
Ensure the manager is properly closed at the end of the script.

## Verification
- Run a small batch of domains to verify stability.
- deliberately kill chrome process during run (simulation) to test recovery.
